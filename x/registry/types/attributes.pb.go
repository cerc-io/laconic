// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: vulcanize/registry/v1beta1/attributes.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ServiceProviderRecord struct {
	BondId    string                      `protobuf:"bytes,1,opt,name=bond_id,json=bondId,proto3" json:"bond_id,omitempty" json:"bondId" yaml:"bondId"`
	LaconicId string                      `protobuf:"bytes,2,opt,name=laconic_id,json=laconicId,proto3" json:"laconic_id,omitempty" json:"laconicId" yaml:"laconicId"`
	X500      *ServiceProviderRecord_X500 `protobuf:"bytes,3,opt,name=x500,proto3" json:"x500,omitempty" json:"x500" yaml:"x500"`
	Type      string                      `protobuf:"bytes,4,opt,name=type,proto3" json:"type,omitempty" json:"type" yaml:"type"`
	Version   string                      `protobuf:"bytes,6,opt,name=version,proto3" json:"version,omitempty" json:"version" yaml:"version"`
}

func (m *ServiceProviderRecord) Reset()         { *m = ServiceProviderRecord{} }
func (m *ServiceProviderRecord) String() string { return proto.CompactTextString(m) }
func (*ServiceProviderRecord) ProtoMessage()    {}
func (*ServiceProviderRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_f305abc771332c96, []int{0}
}
func (m *ServiceProviderRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceProviderRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceProviderRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServiceProviderRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceProviderRecord.Merge(m, src)
}
func (m *ServiceProviderRecord) XXX_Size() int {
	return m.Size()
}
func (m *ServiceProviderRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceProviderRecord.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceProviderRecord proto.InternalMessageInfo

func (m *ServiceProviderRecord) GetBondId() string {
	if m != nil {
		return m.BondId
	}
	return ""
}

func (m *ServiceProviderRecord) GetLaconicId() string {
	if m != nil {
		return m.LaconicId
	}
	return ""
}

func (m *ServiceProviderRecord) GetX500() *ServiceProviderRecord_X500 {
	if m != nil {
		return m.X500
	}
	return nil
}

func (m *ServiceProviderRecord) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *ServiceProviderRecord) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

type ServiceProviderRecord_X500 struct {
	CommonName       string `protobuf:"bytes,1,opt,name=common_name,json=commonName,proto3" json:"common_name,omitempty" json:"commonName" yaml:"commonName"`
	OrganizationUnit string `protobuf:"bytes,2,opt,name=organization_unit,json=organizationUnit,proto3" json:"organization_unit,omitempty" json:"organizationUnit" yaml:"organizationUnit"`
	OrganizationName string `protobuf:"bytes,3,opt,name=organization_name,json=organizationName,proto3" json:"organization_name,omitempty" json:"organizationName" yaml:"organizationName"`
	LocalityName     string `protobuf:"bytes,4,opt,name=locality_name,json=localityName,proto3" json:"locality_name,omitempty" json:"localityName" yaml:"localityName"`
	StateName        string `protobuf:"bytes,5,opt,name=state_name,json=stateName,proto3" json:"state_name,omitempty" json:"stateName" yaml:"stateName"`
	Country          string `protobuf:"bytes,6,opt,name=country,proto3" json:"country,omitempty" json:"country" yaml:"country"`
}

func (m *ServiceProviderRecord_X500) Reset()         { *m = ServiceProviderRecord_X500{} }
func (m *ServiceProviderRecord_X500) String() string { return proto.CompactTextString(m) }
func (*ServiceProviderRecord_X500) ProtoMessage()    {}
func (*ServiceProviderRecord_X500) Descriptor() ([]byte, []int) {
	return fileDescriptor_f305abc771332c96, []int{0, 0}
}
func (m *ServiceProviderRecord_X500) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ServiceProviderRecord_X500) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ServiceProviderRecord_X500.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ServiceProviderRecord_X500) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ServiceProviderRecord_X500.Merge(m, src)
}
func (m *ServiceProviderRecord_X500) XXX_Size() int {
	return m.Size()
}
func (m *ServiceProviderRecord_X500) XXX_DiscardUnknown() {
	xxx_messageInfo_ServiceProviderRecord_X500.DiscardUnknown(m)
}

var xxx_messageInfo_ServiceProviderRecord_X500 proto.InternalMessageInfo

func (m *ServiceProviderRecord_X500) GetCommonName() string {
	if m != nil {
		return m.CommonName
	}
	return ""
}

func (m *ServiceProviderRecord_X500) GetOrganizationUnit() string {
	if m != nil {
		return m.OrganizationUnit
	}
	return ""
}

func (m *ServiceProviderRecord_X500) GetOrganizationName() string {
	if m != nil {
		return m.OrganizationName
	}
	return ""
}

func (m *ServiceProviderRecord_X500) GetLocalityName() string {
	if m != nil {
		return m.LocalityName
	}
	return ""
}

func (m *ServiceProviderRecord_X500) GetStateName() string {
	if m != nil {
		return m.StateName
	}
	return ""
}

func (m *ServiceProviderRecord_X500) GetCountry() string {
	if m != nil {
		return m.Country
	}
	return ""
}

type WebsiteRegistrationRecord struct {
	Url              string            `protobuf:"bytes,1,opt,name=url,proto3" json:"url,omitempty" json:"url" yaml:"url"`
	RepoReference    map[string]string `protobuf:"bytes,2,rep,name=repo_reference,json=repoReference,proto3" json:"repo_reference,omitempty" json:"repoReference" yaml:"repoReference" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	BuildArtifactRef map[string]string `protobuf:"bytes,3,rep,name=build_artifact_ref,json=buildArtifactRef,proto3" json:"build_artifact_ref,omitempty" json:"buildArtifactRef" yaml:"buildArtifactRef" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	TlsCertRef       map[string]string `protobuf:"bytes,4,rep,name=tls_cert_ref,json=tlsCertRef,proto3" json:"tls_cert_ref,omitempty" json:"tlsCertRef" yaml:"tlsCertRef" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Type             string            `protobuf:"bytes,5,opt,name=type,proto3" json:"type,omitempty" json:"type" yaml:"type"`
	Version          string            `protobuf:"bytes,6,opt,name=version,proto3" json:"version,omitempty" json:"version" yaml:"version"`
}

func (m *WebsiteRegistrationRecord) Reset()         { *m = WebsiteRegistrationRecord{} }
func (m *WebsiteRegistrationRecord) String() string { return proto.CompactTextString(m) }
func (*WebsiteRegistrationRecord) ProtoMessage()    {}
func (*WebsiteRegistrationRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_f305abc771332c96, []int{1}
}
func (m *WebsiteRegistrationRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WebsiteRegistrationRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WebsiteRegistrationRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WebsiteRegistrationRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WebsiteRegistrationRecord.Merge(m, src)
}
func (m *WebsiteRegistrationRecord) XXX_Size() int {
	return m.Size()
}
func (m *WebsiteRegistrationRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_WebsiteRegistrationRecord.DiscardUnknown(m)
}

var xxx_messageInfo_WebsiteRegistrationRecord proto.InternalMessageInfo

func (m *WebsiteRegistrationRecord) GetUrl() string {
	if m != nil {
		return m.Url
	}
	return ""
}

func (m *WebsiteRegistrationRecord) GetRepoReference() map[string]string {
	if m != nil {
		return m.RepoReference
	}
	return nil
}

func (m *WebsiteRegistrationRecord) GetBuildArtifactRef() map[string]string {
	if m != nil {
		return m.BuildArtifactRef
	}
	return nil
}

func (m *WebsiteRegistrationRecord) GetTlsCertRef() map[string]string {
	if m != nil {
		return m.TlsCertRef
	}
	return nil
}

func (m *WebsiteRegistrationRecord) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *WebsiteRegistrationRecord) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

type GitRepository struct {
	Name          string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty" json:"name" yaml:"name"`
	RepoReference string `protobuf:"bytes,2,opt,name=repo_reference,json=repoReference,proto3" json:"repo_reference,omitempty" json:"repo_reference" yaml:"repo_reference"`
	Description   string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty" json:"description" yaml:"description"`
	Version       string `protobuf:"bytes,4,opt,name=version,proto3" json:"version,omitempty" json:"version" yaml:"version"`
	Type          string `protobuf:"bytes,5,opt,name=type,proto3" json:"type,omitempty" json:"type" yaml:"type"`
}

func (m *GitRepository) Reset()         { *m = GitRepository{} }
func (m *GitRepository) String() string { return proto.CompactTextString(m) }
func (*GitRepository) ProtoMessage()    {}
func (*GitRepository) Descriptor() ([]byte, []int) {
	return fileDescriptor_f305abc771332c96, []int{2}
}
func (m *GitRepository) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GitRepository) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GitRepository.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GitRepository) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GitRepository.Merge(m, src)
}
func (m *GitRepository) XXX_Size() int {
	return m.Size()
}
func (m *GitRepository) XXX_DiscardUnknown() {
	xxx_messageInfo_GitRepository.DiscardUnknown(m)
}

var xxx_messageInfo_GitRepository proto.InternalMessageInfo

func (m *GitRepository) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GitRepository) GetRepoReference() string {
	if m != nil {
		return m.RepoReference
	}
	return ""
}

func (m *GitRepository) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *GitRepository) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *GitRepository) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

type Binary struct {
	HashReference  map[string]string `protobuf:"bytes,1,rep,name=hash_reference,json=hashReference,proto3" json:"hash_reference,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	TargetedArch   string            `protobuf:"bytes,2,opt,name=targeted_arch,json=targetedArch,proto3" json:"targeted_arch,omitempty"`
	RuntimeVersion string            `protobuf:"bytes,3,opt,name=runtime_version,json=runtimeVersion,proto3" json:"runtime_version,omitempty"`
	RepoReference  map[string]string `protobuf:"bytes,4,rep,name=repo_reference,json=repoReference,proto3" json:"repo_reference,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Version        string            `protobuf:"bytes,5,opt,name=version,proto3" json:"version,omitempty"`
	Type           string            `protobuf:"bytes,6,opt,name=type,proto3" json:"type,omitempty"`
}

func (m *Binary) Reset()         { *m = Binary{} }
func (m *Binary) String() string { return proto.CompactTextString(m) }
func (*Binary) ProtoMessage()    {}
func (*Binary) Descriptor() ([]byte, []int) {
	return fileDescriptor_f305abc771332c96, []int{3}
}
func (m *Binary) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Binary) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Binary.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Binary) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Binary.Merge(m, src)
}
func (m *Binary) XXX_Size() int {
	return m.Size()
}
func (m *Binary) XXX_DiscardUnknown() {
	xxx_messageInfo_Binary.DiscardUnknown(m)
}

var xxx_messageInfo_Binary proto.InternalMessageInfo

func (m *Binary) GetHashReference() map[string]string {
	if m != nil {
		return m.HashReference
	}
	return nil
}

func (m *Binary) GetTargetedArch() string {
	if m != nil {
		return m.TargetedArch
	}
	return ""
}

func (m *Binary) GetRuntimeVersion() string {
	if m != nil {
		return m.RuntimeVersion
	}
	return ""
}

func (m *Binary) GetRepoReference() map[string]string {
	if m != nil {
		return m.RepoReference
	}
	return nil
}

func (m *Binary) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *Binary) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

type DockerImage struct {
	ImageId         string            `protobuf:"bytes,1,opt,name=image_id,json=imageId,proto3" json:"image_id,omitempty"`
	BinaryReference map[string]string `protobuf:"bytes,2,rep,name=binary_reference,json=binaryReference,proto3" json:"binary_reference,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	RepoReference   map[string]string `protobuf:"bytes,3,rep,name=repo_reference,json=repoReference,proto3" json:"repo_reference,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Version         string            `protobuf:"bytes,4,opt,name=version,proto3" json:"version,omitempty"`
	Type            string            `protobuf:"bytes,5,opt,name=type,proto3" json:"type,omitempty"`
}

func (m *DockerImage) Reset()         { *m = DockerImage{} }
func (m *DockerImage) String() string { return proto.CompactTextString(m) }
func (*DockerImage) ProtoMessage()    {}
func (*DockerImage) Descriptor() ([]byte, []int) {
	return fileDescriptor_f305abc771332c96, []int{4}
}
func (m *DockerImage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DockerImage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DockerImage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DockerImage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DockerImage.Merge(m, src)
}
func (m *DockerImage) XXX_Size() int {
	return m.Size()
}
func (m *DockerImage) XXX_DiscardUnknown() {
	xxx_messageInfo_DockerImage.DiscardUnknown(m)
}

var xxx_messageInfo_DockerImage proto.InternalMessageInfo

func (m *DockerImage) GetImageId() string {
	if m != nil {
		return m.ImageId
	}
	return ""
}

func (m *DockerImage) GetBinaryReference() map[string]string {
	if m != nil {
		return m.BinaryReference
	}
	return nil
}

func (m *DockerImage) GetRepoReference() map[string]string {
	if m != nil {
		return m.RepoReference
	}
	return nil
}

func (m *DockerImage) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *DockerImage) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

type WatcherRegistrationRecord struct {
	Metadata      *WatcherRegistrationRecord_WatcherMetadata `protobuf:"bytes,1,opt,name=metadata,proto3" json:"metadata,omitempty"`
	RepoReference map[string]string                          `protobuf:"bytes,2,rep,name=repo_reference,json=repoReference,proto3" json:"repo_reference,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Wasm          *WatcherRegistrationRecord_WASMBinary      `protobuf:"bytes,3,opt,name=wasm,proto3" json:"wasm,omitempty"`
	Version       string                                     `protobuf:"bytes,4,opt,name=version,proto3" json:"version,omitempty"`
	Type          string                                     `protobuf:"bytes,5,opt,name=type,proto3" json:"type,omitempty"`
}

func (m *WatcherRegistrationRecord) Reset()         { *m = WatcherRegistrationRecord{} }
func (m *WatcherRegistrationRecord) String() string { return proto.CompactTextString(m) }
func (*WatcherRegistrationRecord) ProtoMessage()    {}
func (*WatcherRegistrationRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_f305abc771332c96, []int{5}
}
func (m *WatcherRegistrationRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WatcherRegistrationRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WatcherRegistrationRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WatcherRegistrationRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WatcherRegistrationRecord.Merge(m, src)
}
func (m *WatcherRegistrationRecord) XXX_Size() int {
	return m.Size()
}
func (m *WatcherRegistrationRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_WatcherRegistrationRecord.DiscardUnknown(m)
}

var xxx_messageInfo_WatcherRegistrationRecord proto.InternalMessageInfo

func (m *WatcherRegistrationRecord) GetMetadata() *WatcherRegistrationRecord_WatcherMetadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *WatcherRegistrationRecord) GetRepoReference() map[string]string {
	if m != nil {
		return m.RepoReference
	}
	return nil
}

func (m *WatcherRegistrationRecord) GetWasm() *WatcherRegistrationRecord_WASMBinary {
	if m != nil {
		return m.Wasm
	}
	return nil
}

func (m *WatcherRegistrationRecord) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *WatcherRegistrationRecord) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

type WatcherRegistrationRecord_WatcherMetadata struct {
	Version        string            `protobuf:"bytes,1,opt,name=version,proto3" json:"version,omitempty"`
	ChainReference map[string]string `protobuf:"bytes,2,rep,name=chain_reference,json=chainReference,proto3" json:"chain_reference,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *WatcherRegistrationRecord_WatcherMetadata) Reset() {
	*m = WatcherRegistrationRecord_WatcherMetadata{}
}
func (m *WatcherRegistrationRecord_WatcherMetadata) String() string {
	return proto.CompactTextString(m)
}
func (*WatcherRegistrationRecord_WatcherMetadata) ProtoMessage() {}
func (*WatcherRegistrationRecord_WatcherMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_f305abc771332c96, []int{5, 1}
}
func (m *WatcherRegistrationRecord_WatcherMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WatcherRegistrationRecord_WatcherMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WatcherRegistrationRecord_WatcherMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WatcherRegistrationRecord_WatcherMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WatcherRegistrationRecord_WatcherMetadata.Merge(m, src)
}
func (m *WatcherRegistrationRecord_WatcherMetadata) XXX_Size() int {
	return m.Size()
}
func (m *WatcherRegistrationRecord_WatcherMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_WatcherRegistrationRecord_WatcherMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_WatcherRegistrationRecord_WatcherMetadata proto.InternalMessageInfo

func (m *WatcherRegistrationRecord_WatcherMetadata) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *WatcherRegistrationRecord_WatcherMetadata) GetChainReference() map[string]string {
	if m != nil {
		return m.ChainReference
	}
	return nil
}

type WatcherRegistrationRecord_WASMBinary struct {
	HashReference map[string]string                             `protobuf:"bytes,1,rep,name=hash_reference,json=hashReference,proto3" json:"hash_reference,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Metadata      *WatcherRegistrationRecord_WASMBinaryMetadata `protobuf:"bytes,2,opt,name=metadata,proto3" json:"metadata,omitempty"`
}

func (m *WatcherRegistrationRecord_WASMBinary) Reset()         { *m = WatcherRegistrationRecord_WASMBinary{} }
func (m *WatcherRegistrationRecord_WASMBinary) String() string { return proto.CompactTextString(m) }
func (*WatcherRegistrationRecord_WASMBinary) ProtoMessage()    {}
func (*WatcherRegistrationRecord_WASMBinary) Descriptor() ([]byte, []int) {
	return fileDescriptor_f305abc771332c96, []int{5, 2}
}
func (m *WatcherRegistrationRecord_WASMBinary) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WatcherRegistrationRecord_WASMBinary) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WatcherRegistrationRecord_WASMBinary.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WatcherRegistrationRecord_WASMBinary) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WatcherRegistrationRecord_WASMBinary.Merge(m, src)
}
func (m *WatcherRegistrationRecord_WASMBinary) XXX_Size() int {
	return m.Size()
}
func (m *WatcherRegistrationRecord_WASMBinary) XXX_DiscardUnknown() {
	xxx_messageInfo_WatcherRegistrationRecord_WASMBinary.DiscardUnknown(m)
}

var xxx_messageInfo_WatcherRegistrationRecord_WASMBinary proto.InternalMessageInfo

func (m *WatcherRegistrationRecord_WASMBinary) GetHashReference() map[string]string {
	if m != nil {
		return m.HashReference
	}
	return nil
}

func (m *WatcherRegistrationRecord_WASMBinary) GetMetadata() *WatcherRegistrationRecord_WASMBinaryMetadata {
	if m != nil {
		return m.Metadata
	}
	return nil
}

type WatcherRegistrationRecord_WASMBinaryMetadata struct {
	CompilerVersion        string `protobuf:"bytes,1,opt,name=compiler_version,json=compilerVersion,proto3" json:"compiler_version,omitempty"`
	ExecutionEngineVersion string `protobuf:"bytes,2,opt,name=execution_engine_version,json=executionEngineVersion,proto3" json:"execution_engine_version,omitempty"`
}

func (m *WatcherRegistrationRecord_WASMBinaryMetadata) Reset() {
	*m = WatcherRegistrationRecord_WASMBinaryMetadata{}
}
func (m *WatcherRegistrationRecord_WASMBinaryMetadata) String() string {
	return proto.CompactTextString(m)
}
func (*WatcherRegistrationRecord_WASMBinaryMetadata) ProtoMessage() {}
func (*WatcherRegistrationRecord_WASMBinaryMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_f305abc771332c96, []int{5, 3}
}
func (m *WatcherRegistrationRecord_WASMBinaryMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WatcherRegistrationRecord_WASMBinaryMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WatcherRegistrationRecord_WASMBinaryMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WatcherRegistrationRecord_WASMBinaryMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WatcherRegistrationRecord_WASMBinaryMetadata.Merge(m, src)
}
func (m *WatcherRegistrationRecord_WASMBinaryMetadata) XXX_Size() int {
	return m.Size()
}
func (m *WatcherRegistrationRecord_WASMBinaryMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_WatcherRegistrationRecord_WASMBinaryMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_WatcherRegistrationRecord_WASMBinaryMetadata proto.InternalMessageInfo

func (m *WatcherRegistrationRecord_WASMBinaryMetadata) GetCompilerVersion() string {
	if m != nil {
		return m.CompilerVersion
	}
	return ""
}

func (m *WatcherRegistrationRecord_WASMBinaryMetadata) GetExecutionEngineVersion() string {
	if m != nil {
		return m.ExecutionEngineVersion
	}
	return ""
}

type ResponderContract struct {
	ServiceProviderRef map[string]string `protobuf:"bytes,1,rep,name=service_provider_ref,json=serviceProviderRef,proto3" json:"service_provider_ref,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	AuctionRef         map[string]string `protobuf:"bytes,2,rep,name=auction_ref,json=auctionRef,proto3" json:"auction_ref,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	WatcherRef         map[string]string `protobuf:"bytes,3,rep,name=watcher_ref,json=watcherRef,proto3" json:"watcher_ref,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Version            string            `protobuf:"bytes,4,opt,name=version,proto3" json:"version,omitempty"`
	Type               string            `protobuf:"bytes,5,opt,name=type,proto3" json:"type,omitempty"`
}

func (m *ResponderContract) Reset()         { *m = ResponderContract{} }
func (m *ResponderContract) String() string { return proto.CompactTextString(m) }
func (*ResponderContract) ProtoMessage()    {}
func (*ResponderContract) Descriptor() ([]byte, []int) {
	return fileDescriptor_f305abc771332c96, []int{6}
}
func (m *ResponderContract) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponderContract) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResponderContract.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResponderContract) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponderContract.Merge(m, src)
}
func (m *ResponderContract) XXX_Size() int {
	return m.Size()
}
func (m *ResponderContract) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponderContract.DiscardUnknown(m)
}

var xxx_messageInfo_ResponderContract proto.InternalMessageInfo

func (m *ResponderContract) GetServiceProviderRef() map[string]string {
	if m != nil {
		return m.ServiceProviderRef
	}
	return nil
}

func (m *ResponderContract) GetAuctionRef() map[string]string {
	if m != nil {
		return m.AuctionRef
	}
	return nil
}

func (m *ResponderContract) GetWatcherRef() map[string]string {
	if m != nil {
		return m.WatcherRef
	}
	return nil
}

func (m *ResponderContract) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *ResponderContract) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

type JSPackage struct {
	RepoReference map[string]string `protobuf:"bytes,1,rep,name=repo_reference,json=repoReference,proto3" json:"repo_reference,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	JsPackageRef  map[string]string `protobuf:"bytes,2,rep,name=js_package_ref,json=jsPackageRef,proto3" json:"js_package_ref,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Version       string            `protobuf:"bytes,3,opt,name=version,proto3" json:"version,omitempty"`
	Type          string            `protobuf:"bytes,4,opt,name=type,proto3" json:"type,omitempty"`
	Name          string            `protobuf:"bytes,5,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *JSPackage) Reset()         { *m = JSPackage{} }
func (m *JSPackage) String() string { return proto.CompactTextString(m) }
func (*JSPackage) ProtoMessage()    {}
func (*JSPackage) Descriptor() ([]byte, []int) {
	return fileDescriptor_f305abc771332c96, []int{7}
}
func (m *JSPackage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JSPackage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JSPackage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JSPackage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JSPackage.Merge(m, src)
}
func (m *JSPackage) XXX_Size() int {
	return m.Size()
}
func (m *JSPackage) XXX_DiscardUnknown() {
	xxx_messageInfo_JSPackage.DiscardUnknown(m)
}

var xxx_messageInfo_JSPackage proto.InternalMessageInfo

func (m *JSPackage) GetRepoReference() map[string]string {
	if m != nil {
		return m.RepoReference
	}
	return nil
}

func (m *JSPackage) GetJsPackageRef() map[string]string {
	if m != nil {
		return m.JsPackageRef
	}
	return nil
}

func (m *JSPackage) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *JSPackage) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *JSPackage) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type ChainRegistrationRecord struct {
	Name        string            `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	IpldTypes   []string          `protobuf:"bytes,2,rep,name=ipld_types,json=ipldTypes,proto3" json:"ipld_types,omitempty"`
	Type        string            `protobuf:"bytes,3,opt,name=type,proto3" json:"type,omitempty"`
	Version     string            `protobuf:"bytes,4,opt,name=version,proto3" json:"version,omitempty"`
	ChainId     string            `protobuf:"bytes,5,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	NetworkId   string            `protobuf:"bytes,6,opt,name=network_id,json=networkId,proto3" json:"network_id,omitempty"`
	GenesisHash map[string]string `protobuf:"bytes,7,rep,name=genesis_hash,json=genesisHash,proto3" json:"genesis_hash,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *ChainRegistrationRecord) Reset()         { *m = ChainRegistrationRecord{} }
func (m *ChainRegistrationRecord) String() string { return proto.CompactTextString(m) }
func (*ChainRegistrationRecord) ProtoMessage()    {}
func (*ChainRegistrationRecord) Descriptor() ([]byte, []int) {
	return fileDescriptor_f305abc771332c96, []int{8}
}
func (m *ChainRegistrationRecord) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChainRegistrationRecord) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChainRegistrationRecord.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChainRegistrationRecord) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChainRegistrationRecord.Merge(m, src)
}
func (m *ChainRegistrationRecord) XXX_Size() int {
	return m.Size()
}
func (m *ChainRegistrationRecord) XXX_DiscardUnknown() {
	xxx_messageInfo_ChainRegistrationRecord.DiscardUnknown(m)
}

var xxx_messageInfo_ChainRegistrationRecord proto.InternalMessageInfo

func (m *ChainRegistrationRecord) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ChainRegistrationRecord) GetIpldTypes() []string {
	if m != nil {
		return m.IpldTypes
	}
	return nil
}

func (m *ChainRegistrationRecord) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

func (m *ChainRegistrationRecord) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *ChainRegistrationRecord) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (m *ChainRegistrationRecord) GetNetworkId() string {
	if m != nil {
		return m.NetworkId
	}
	return ""
}

func (m *ChainRegistrationRecord) GetGenesisHash() map[string]string {
	if m != nil {
		return m.GenesisHash
	}
	return nil
}

func init() {
	proto.RegisterType((*ServiceProviderRecord)(nil), "vulcanize.registry.v1beta1.ServiceProviderRecord")
	proto.RegisterType((*ServiceProviderRecord_X500)(nil), "vulcanize.registry.v1beta1.ServiceProviderRecord.X500")
	proto.RegisterType((*WebsiteRegistrationRecord)(nil), "vulcanize.registry.v1beta1.WebsiteRegistrationRecord")
	proto.RegisterMapType((map[string]string)(nil), "vulcanize.registry.v1beta1.WebsiteRegistrationRecord.BuildArtifactRefEntry")
	proto.RegisterMapType((map[string]string)(nil), "vulcanize.registry.v1beta1.WebsiteRegistrationRecord.RepoReferenceEntry")
	proto.RegisterMapType((map[string]string)(nil), "vulcanize.registry.v1beta1.WebsiteRegistrationRecord.TlsCertRefEntry")
	proto.RegisterType((*GitRepository)(nil), "vulcanize.registry.v1beta1.GitRepository")
	proto.RegisterType((*Binary)(nil), "vulcanize.registry.v1beta1.Binary")
	proto.RegisterMapType((map[string]string)(nil), "vulcanize.registry.v1beta1.Binary.HashReferenceEntry")
	proto.RegisterMapType((map[string]string)(nil), "vulcanize.registry.v1beta1.Binary.RepoReferenceEntry")
	proto.RegisterType((*DockerImage)(nil), "vulcanize.registry.v1beta1.DockerImage")
	proto.RegisterMapType((map[string]string)(nil), "vulcanize.registry.v1beta1.DockerImage.BinaryReferenceEntry")
	proto.RegisterMapType((map[string]string)(nil), "vulcanize.registry.v1beta1.DockerImage.RepoReferenceEntry")
	proto.RegisterType((*WatcherRegistrationRecord)(nil), "vulcanize.registry.v1beta1.WatcherRegistrationRecord")
	proto.RegisterMapType((map[string]string)(nil), "vulcanize.registry.v1beta1.WatcherRegistrationRecord.RepoReferenceEntry")
	proto.RegisterType((*WatcherRegistrationRecord_WatcherMetadata)(nil), "vulcanize.registry.v1beta1.WatcherRegistrationRecord.WatcherMetadata")
	proto.RegisterMapType((map[string]string)(nil), "vulcanize.registry.v1beta1.WatcherRegistrationRecord.WatcherMetadata.ChainReferenceEntry")
	proto.RegisterType((*WatcherRegistrationRecord_WASMBinary)(nil), "vulcanize.registry.v1beta1.WatcherRegistrationRecord.WASMBinary")
	proto.RegisterMapType((map[string]string)(nil), "vulcanize.registry.v1beta1.WatcherRegistrationRecord.WASMBinary.HashReferenceEntry")
	proto.RegisterType((*WatcherRegistrationRecord_WASMBinaryMetadata)(nil), "vulcanize.registry.v1beta1.WatcherRegistrationRecord.WASMBinaryMetadata")
	proto.RegisterType((*ResponderContract)(nil), "vulcanize.registry.v1beta1.ResponderContract")
	proto.RegisterMapType((map[string]string)(nil), "vulcanize.registry.v1beta1.ResponderContract.AuctionRefEntry")
	proto.RegisterMapType((map[string]string)(nil), "vulcanize.registry.v1beta1.ResponderContract.ServiceProviderRefEntry")
	proto.RegisterMapType((map[string]string)(nil), "vulcanize.registry.v1beta1.ResponderContract.WatcherRefEntry")
	proto.RegisterType((*JSPackage)(nil), "vulcanize.registry.v1beta1.JSPackage")
	proto.RegisterMapType((map[string]string)(nil), "vulcanize.registry.v1beta1.JSPackage.JsPackageRefEntry")
	proto.RegisterMapType((map[string]string)(nil), "vulcanize.registry.v1beta1.JSPackage.RepoReferenceEntry")
	proto.RegisterType((*ChainRegistrationRecord)(nil), "vulcanize.registry.v1beta1.ChainRegistrationRecord")
	proto.RegisterMapType((map[string]string)(nil), "vulcanize.registry.v1beta1.ChainRegistrationRecord.GenesisHashEntry")
}

func init() {
	proto.RegisterFile("vulcanize/registry/v1beta1/attributes.proto", fileDescriptor_f305abc771332c96)
}

var fileDescriptor_f305abc771332c96 = []byte{
	// 1526 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x58, 0x4f, 0x6f, 0x13, 0x47,
	0x14, 0x67, 0x63, 0xe7, 0xdf, 0xcb, 0x5f, 0xa6, 0xa1, 0x38, 0x41, 0xc4, 0xc1, 0x08, 0x01, 0x4a,
	0xb1, 0x03, 0x88, 0x36, 0xa2, 0xa5, 0x25, 0x09, 0x29, 0x01, 0x44, 0x85, 0x26, 0x14, 0xda, 0x8a,
	0xd6, 0x1d, 0xaf, 0x07, 0x7b, 0x88, 0xbd, 0x6b, 0xcd, 0x8e, 0x13, 0xcc, 0xb1, 0x9f, 0x80, 0x4f,
	0xd0, 0x73, 0x4f, 0x55, 0xbf, 0x41, 0x2f, 0x3d, 0xf4, 0x88, 0xd4, 0x4b, 0x5b, 0xa9, 0x56, 0x0b,
	0xa7, 0x5e, 0xdd, 0x2f, 0x50, 0xcd, 0xcc, 0xfe, 0x19, 0x7b, 0xe3, 0x90, 0x4d, 0x10, 0xb7, 0x99,
	0xf7, 0xe6, 0xfd, 0xfd, 0xbd, 0x37, 0xf3, 0x76, 0x61, 0x71, 0xbb, 0x59, 0xb3, 0x89, 0xc3, 0x9e,
	0xd1, 0x02, 0xa7, 0x15, 0xe6, 0x09, 0xde, 0x2a, 0x6c, 0x5f, 0x2c, 0x51, 0x41, 0x2e, 0x16, 0x88,
	0x10, 0x9c, 0x95, 0x9a, 0x82, 0x7a, 0xf9, 0x06, 0x77, 0x85, 0x8b, 0xe6, 0xc2, 0xc3, 0xf9, 0xe0,
	0x70, 0xde, 0x3f, 0x3c, 0x37, 0x53, 0x71, 0x2b, 0xae, 0x3a, 0x56, 0x90, 0x2b, 0x2d, 0x91, 0xfb,
	0x73, 0x08, 0x8e, 0x6d, 0x52, 0xbe, 0xcd, 0x6c, 0x7a, 0x8f, 0xbb, 0xdb, 0xac, 0x4c, 0x39, 0xa6,
	0xb6, 0xcb, 0xcb, 0x68, 0x19, 0x86, 0x4b, 0xae, 0x53, 0x2e, 0xb2, 0x72, 0xc6, 0x5a, 0xb0, 0xce,
	0x8d, 0xae, 0x66, 0x3b, 0xed, 0xec, 0x89, 0x27, 0x9e, 0xeb, 0x5c, 0xcd, 0x49, 0xc6, 0xad, 0x72,
	0x6e, 0xa1, 0x45, 0xea, 0xb5, 0x70, 0x87, 0x87, 0xf4, 0x02, 0xdd, 0x00, 0xa8, 0x11, 0xdb, 0x75,
	0x98, 0x2d, 0x85, 0x07, 0x94, 0xf0, 0x99, 0x4e, 0x3b, 0x7b, 0x4a, 0x0b, 0xfb, 0xbc, 0x48, 0x3e,
	0x22, 0xe0, 0xd1, 0x70, 0x8d, 0x2a, 0x90, 0x7e, 0x7a, 0x65, 0x69, 0x29, 0x93, 0x5a, 0xb0, 0xce,
	0x8d, 0x5d, 0x7a, 0x3f, 0xdf, 0x3f, 0xb4, 0xfc, 0xae, 0x01, 0xe4, 0xbf, 0xb8, 0xb2, 0xb4, 0xb4,
	0x7a, 0xa2, 0xd3, 0xce, 0x1e, 0xd7, 0x76, 0xa5, 0xb6, 0xc0, 0xa4, 0x5a, 0x63, 0x65, 0x00, 0x15,
	0x20, 0x2d, 0x5a, 0x0d, 0x9a, 0x49, 0x2b, 0x47, 0x0d, 0x01, 0x49, 0x0d, 0x04, 0xd4, 0x1a, 0xab,
	0x83, 0xe8, 0x43, 0x18, 0xde, 0xa6, 0xdc, 0x63, 0xae, 0x93, 0x19, 0x52, 0x32, 0xa7, 0x3a, 0xed,
	0xec, 0x49, 0x2d, 0xe3, 0x33, 0x02, 0xb1, 0x60, 0x8b, 0x03, 0x89, 0xb9, 0x7f, 0x53, 0x90, 0x96,
	0x9e, 0xa1, 0x0d, 0x18, 0xb3, 0xdd, 0x7a, 0xdd, 0x75, 0x8a, 0x0e, 0xa9, 0x53, 0x3f, 0xc7, 0x67,
	0x3b, 0xed, 0xec, 0x69, 0xad, 0x49, 0x33, 0x3f, 0x23, 0xf5, 0xd0, 0x07, 0x83, 0x82, 0x21, 0xda,
	0xa0, 0x6f, 0xe1, 0xa8, 0xcb, 0x2b, 0x32, 0x37, 0x44, 0x30, 0xd7, 0x29, 0x36, 0x1d, 0x26, 0xfc,
	0xb4, 0x5f, 0xee, 0xb4, 0xb3, 0x05, 0xad, 0xcf, 0x3c, 0xf2, 0xb9, 0xc3, 0x44, 0xa0, 0x35, 0x46,
	0xc7, 0xd3, 0xbd, 0xa4, 0x98, 0x05, 0xe5, 0x71, 0x6a, 0x2f, 0x0b, 0xa6, 0xdf, 0x31, 0x7a, 0xb7,
	0x05, 0x15, 0xc3, 0x3d, 0x98, 0xa8, 0xb9, 0x36, 0xa9, 0x31, 0xd1, 0xd2, 0xda, 0x35, 0x1a, 0x8b,
	0x9d, 0x76, 0xf6, 0xac, 0x5f, 0x36, 0x3e, 0xdb, 0xd4, 0xdc, 0x45, 0xc3, 0xe3, 0xe6, 0x56, 0x56,
	0xa1, 0x27, 0x88, 0xa0, 0x5a, 0xdd, 0x60, 0x6f, 0x15, 0x2a, 0x9e, 0xa9, 0x2b, 0x22, 0xe0, 0xd1,
	0x70, 0x2d, 0xb1, 0xb6, 0xdd, 0xa6, 0x23, 0x78, 0x2b, 0x8e, 0xb5, 0xcf, 0x88, 0xe0, 0xd1, 0x5b,
	0x1c, 0x48, 0xe4, 0xfe, 0x19, 0x82, 0xd9, 0x87, 0xb4, 0xe4, 0x31, 0x41, 0xb1, 0xae, 0x59, 0x15,
	0xb0, 0xdf, 0x60, 0x8b, 0x90, 0x6a, 0xf2, 0x9a, 0x0f, 0xfc, 0x6c, 0xa7, 0x9d, 0x3d, 0xa6, 0xd5,
	0x36, 0x79, 0x2d, 0x50, 0x29, 0x97, 0x58, 0x9e, 0x42, 0xdf, 0x5b, 0x30, 0xc9, 0x69, 0xc3, 0x2d,
	0x72, 0xfa, 0x98, 0x72, 0xea, 0xd8, 0x34, 0x33, 0xb0, 0x90, 0x3a, 0x37, 0x76, 0x69, 0x63, 0xaf,
	0xc6, 0xe8, 0x6b, 0x3c, 0x8f, 0x69, 0xc3, 0xc5, 0x81, 0xaa, 0x75, 0xe9, 0xed, 0xea, 0x85, 0x4e,
	0x3b, 0x7b, 0x5e, 0xbb, 0xc0, 0x4d, 0x6e, 0xe0, 0x4c, 0x37, 0x11, 0x4f, 0x74, 0xed, 0xd1, 0x8f,
	0x16, 0xa0, 0x52, 0x93, 0xd5, 0xca, 0x45, 0xc2, 0x05, 0x7b, 0x4c, 0x6c, 0x21, 0x5d, 0xcd, 0xa4,
	0x94, 0x93, 0x77, 0x0e, 0xe6, 0xe4, 0xaa, 0xd4, 0xb7, 0xe2, 0xab, 0xc3, 0xf4, 0xb1, 0xf6, 0xd3,
	0xa8, 0xb8, 0x52, 0xcf, 0x81, 0xf0, 0x46, 0xea, 0xa5, 0xe3, 0xe9, 0x5e, 0x12, 0x7a, 0x6e, 0xc1,
	0xb8, 0xa8, 0x79, 0x45, 0x9b, 0x72, 0xed, 0x6a, 0x5a, 0xb9, 0xba, 0x7e, 0x30, 0x57, 0xef, 0xd7,
	0xbc, 0x35, 0xca, 0x23, 0x27, 0x8d, 0x46, 0x16, 0x21, 0x2b, 0xbc, 0x4c, 0x22, 0x0a, 0x86, 0x68,
	0x13, 0xde, 0x44, 0x83, 0x6f, 0xe5, 0x26, 0xba, 0x0e, 0x28, 0x5e, 0x05, 0x68, 0x1a, 0x52, 0x5b,
	0xb4, 0xa5, 0xab, 0x12, 0xcb, 0x25, 0x9a, 0x81, 0xc1, 0x6d, 0x52, 0x6b, 0x52, 0x7d, 0xa5, 0x60,
	0xbd, 0xb9, 0x3a, 0xb0, 0x6c, 0xcd, 0xad, 0xc1, 0xb1, 0x5d, 0x21, 0x4a, 0xa4, 0xe4, 0x1a, 0x4c,
	0xf5, 0x24, 0x2f, 0x89, 0x78, 0xee, 0xb7, 0x01, 0x98, 0xb8, 0xc9, 0x84, 0x8c, 0xc4, 0x63, 0xc2,
	0xe5, 0x2d, 0x99, 0x45, 0xe3, 0x46, 0x35, 0xb2, 0xe8, 0x18, 0xdd, 0xae, 0xd6, 0x58, 0x1d, 0x44,
	0x0f, 0x76, 0x69, 0x2d, 0x29, 0x5a, 0xe8, 0xb4, 0xb3, 0x8b, 0x51, 0x43, 0x44, 0x7c, 0xb3, 0x23,
	0x0c, 0x6a, 0x6f, 0x4b, 0xdc, 0x81, 0xb1, 0x32, 0xf5, 0x6c, 0xce, 0x1a, 0xb2, 0x50, 0xfc, 0xfb,
	0xf2, 0x7c, 0xa7, 0x9d, 0x3d, 0xa3, 0x95, 0x1a, 0xcc, 0x40, 0xa3, 0x49, 0xc2, 0xa6, 0xb4, 0x09,
	0x75, 0x3a, 0x29, 0xd4, 0x89, 0x0b, 0x2b, 0xf7, 0x4b, 0x0a, 0x86, 0x56, 0x99, 0x43, 0x78, 0x0b,
	0x3d, 0x82, 0xc9, 0x2a, 0xf1, 0xaa, 0x46, 0x76, 0x2c, 0xd5, 0x28, 0x57, 0xf6, 0x6a, 0x14, 0x2d,
	0x9b, 0xdf, 0x20, 0x5e, 0xb5, 0xbb, 0xbe, 0xf0, 0x44, 0xd5, 0xa4, 0xa1, 0xd3, 0x30, 0x21, 0x08,
	0xaf, 0x50, 0x41, 0xe5, 0xc5, 0x61, 0x57, 0x7d, 0x80, 0xc7, 0x03, 0xe2, 0x0a, 0xb7, 0xab, 0xe8,
	0x2c, 0x4c, 0xf1, 0xa6, 0x23, 0x58, 0x9d, 0x16, 0x83, 0x1c, 0xa8, 0x64, 0xe2, 0x49, 0x9f, 0xfc,
	0xc0, 0x8f, 0xf3, 0x51, 0x0c, 0xc9, 0xf4, 0xbe, 0x7d, 0x8d, 0xf7, 0x42, 0x2f, 0x9e, 0x99, 0x08,
	0x02, 0x95, 0xc8, 0x28, 0xbf, 0xc8, 0xcf, 0xaf, 0x6a, 0x42, 0x9d, 0x42, 0xd9, 0x5e, 0xf1, 0xf0,
	0x13, 0x75, 0xc6, 0xa1, 0x1b, 0x34, 0xf7, 0x43, 0x0a, 0xc6, 0x6e, 0xb8, 0xf6, 0x16, 0xe5, 0xb7,
	0xea, 0xa4, 0x42, 0xd1, 0x2c, 0x8c, 0x30, 0xb9, 0x08, 0x87, 0x3a, 0x3c, 0xac, 0xf6, 0x6a, 0xdc,
	0x9a, 0x2e, 0xa9, 0x44, 0xc4, 0x5e, 0x98, 0x8f, 0xf6, 0x4a, 0x9e, 0xa1, 0xdd, 0x4f, 0x64, 0x4f,
	0x0e, 0xa7, 0x4a, 0xdd, 0x54, 0x44, 0x62, 0x18, 0xe9, 0x37, 0xe2, 0xea, 0x7e, 0xcd, 0x24, 0x02,
	0x2a, 0xbd, 0x3b, 0x50, 0x83, 0x06, 0x50, 0xab, 0x30, 0xb3, 0x9b, 0xe7, 0x6f, 0x19, 0xaa, 0x3f,
	0x46, 0x60, 0xf6, 0x21, 0x11, 0x76, 0x55, 0xce, 0xaf, 0xb1, 0x59, 0x81, 0xc0, 0x48, 0x9d, 0x0a,
	0x52, 0x26, 0x82, 0x28, 0x75, 0xaf, 0x7b, 0xa7, 0xfa, 0x29, 0x0a, 0x38, 0x77, 0x7d, 0x65, 0x38,
	0x54, 0x8b, 0xdc, 0x03, 0x0d, 0x18, 0x7d, 0x0d, 0xbd, 0x1e, 0xa5, 0xfb, 0x90, 0xde, 0x21, 0x5e,
	0xdd, 0x1f, 0xf0, 0xaf, 0x1f, 0x30, 0x9e, 0x95, 0xcd, 0xbb, 0x3e, 0x7a, 0x4a, 0x5b, 0x42, 0xec,
	0x0f, 0xff, 0x06, 0xfe, 0x67, 0xc1, 0x54, 0x4f, 0x52, 0x4d, 0x1f, 0xac, 0x6e, 0x1f, 0xbe, 0xb3,
	0x60, 0xca, 0xae, 0x12, 0xe6, 0xc4, 0xd2, 0xfc, 0xe5, 0x1b, 0xc1, 0x33, 0xbf, 0x26, 0x95, 0xf7,
	0xe4, 0x7d, 0xd2, 0xee, 0x22, 0xce, 0xad, 0xc0, 0x3b, 0xbb, 0x1c, 0x4b, 0x14, 0xf5, 0x4f, 0x03,
	0x00, 0x51, 0xea, 0xd1, 0xb3, 0x3e, 0x6f, 0xc4, 0xe6, 0x61, 0x41, 0xdd, 0xc7, 0x0b, 0x52, 0x36,
	0x5a, 0x63, 0x40, 0x95, 0xd2, 0xc6, 0x61, 0xad, 0xc6, 0xbb, 0xe3, 0x0d, 0xdc, 0xe6, 0x2d, 0x40,
	0x71, 0x0b, 0xe8, 0x3c, 0x4c, 0xdb, 0x6e, 0xbd, 0xc1, 0x6a, 0x94, 0x17, 0xbb, 0x6b, 0x66, 0x2a,
	0xa0, 0x07, 0x8f, 0xdb, 0x32, 0x64, 0xe8, 0x53, 0x6a, 0x37, 0xd5, 0x17, 0x18, 0x75, 0x2a, 0xcc,
	0x89, 0x9e, 0x43, 0x6d, 0xed, 0xdd, 0x90, 0xbf, 0xae, 0xd8, 0xbe, 0x64, 0xee, 0xe7, 0x34, 0x1c,
	0xc5, 0xd4, 0x6b, 0xb8, 0x4e, 0x99, 0xf2, 0x35, 0xd7, 0x11, 0x9c, 0xd8, 0x02, 0xed, 0xc0, 0x8c,
	0xa7, 0x3f, 0x9c, 0x8b, 0x0d, 0xff, 0xcb, 0x59, 0xcd, 0xc1, 0xd6, 0xeb, 0xe7, 0xe0, 0x98, 0xb2,
	0xf8, 0x27, 0xb8, 0x1e, 0xe5, 0x30, 0xf2, 0x62, 0x0c, 0xf4, 0x0d, 0x8c, 0x91, 0xa6, 0xad, 0xc2,
	0x90, 0xf6, 0x74, 0xfd, 0x5f, 0x4b, 0x66, 0x6f, 0x45, 0x2b, 0x08, 0xed, 0x00, 0x09, 0x09, 0x52,
	0xff, 0x8e, 0x46, 0xd9, 0xf8, 0x04, 0x49, 0xa8, 0x3f, 0x2c, 0x93, 0x40, 0xff, 0x4e, 0x48, 0x48,
	0x78, 0xc5, 0xac, 0xc3, 0xf1, 0x3e, 0xc9, 0x49, 0x3a, 0x26, 0xf7, 0xc4, 0x9c, 0x54, 0xbc, 0x27,
	0xa4, 0x44, 0xaf, 0xd3, 0xf3, 0x14, 0x8c, 0xde, 0xde, 0xbc, 0x47, 0xec, 0x2d, 0x39, 0x46, 0x14,
	0x63, 0x4f, 0x85, 0xae, 0x99, 0xe5, 0xbd, 0x72, 0x1c, 0x8a, 0xef, 0xe3, 0x69, 0xf8, 0x1a, 0x26,
	0x9f, 0x78, 0xc5, 0x86, 0x3e, 0x6f, 0x14, 0xc9, 0x07, 0xfb, 0x33, 0x70, 0xdb, 0xf3, 0x57, 0x21,
	0x7c, 0xe3, 0x4f, 0x0c, 0x92, 0x09, 0x60, 0x6a, 0x77, 0x00, 0xd3, 0x11, 0x80, 0x92, 0x16, 0xfd,
	0x42, 0xd0, 0x9f, 0x0c, 0x6f, 0xe0, 0xdd, 0xf8, 0x04, 0x8e, 0xc6, 0xdc, 0x4c, 0x04, 0xc9, 0x5f,
	0x03, 0x70, 0xdc, 0xbf, 0xc6, 0x63, 0xe3, 0x02, 0x32, 0x3f, 0x81, 0xfc, 0xaf, 0x9c, 0x93, 0x00,
	0xac, 0x51, 0x2b, 0x17, 0x65, 0x4c, 0x9e, 0xca, 0xe7, 0x28, 0x1e, 0x95, 0x94, 0xfb, 0x92, 0x10,
	0x46, 0x9e, 0x32, 0x22, 0xef, 0x5f, 0xe8, 0xb3, 0x30, 0xa2, 0x9f, 0x31, 0x56, 0x0e, 0x66, 0x61,
	0xb5, 0xbf, 0x55, 0x96, 0x76, 0x1c, 0x2a, 0x76, 0x5c, 0xbe, 0x25, 0x99, 0x7a, 0x22, 0x1e, 0xf5,
	0x29, 0x6a, 0xce, 0x1c, 0xaf, 0x50, 0x87, 0x7a, 0xcc, 0x2b, 0xca, 0x7b, 0x3c, 0x33, 0xac, 0x80,
	0xbd, 0xb1, 0x17, 0xb0, 0x7d, 0xa2, 0xcc, 0xdf, 0xd4, 0x7a, 0xe4, 0xbd, 0xac, 0x51, 0x1e, 0xab,
	0x44, 0x94, 0xb9, 0x8f, 0x61, 0xba, 0xf7, 0x40, 0x92, 0xfc, 0xae, 0x7e, 0xfa, 0xeb, 0xcb, 0x79,
	0xeb, 0xc5, 0xcb, 0x79, 0xeb, 0xef, 0x97, 0xf3, 0xd6, 0xf3, 0x57, 0xf3, 0x47, 0x5e, 0xbc, 0x9a,
	0x3f, 0xf2, 0xfb, 0xab, 0xf9, 0x23, 0x5f, 0xbd, 0x57, 0x61, 0xa2, 0xda, 0x2c, 0xe5, 0x6d, 0xb7,
	0x5e, 0xb0, 0x29, 0xb7, 0x2f, 0x30, 0xb7, 0xe0, 0xff, 0xb7, 0x2c, 0x17, 0x9e, 0x46, 0xbf, 0x69,
	0x55, 0xa6, 0x4b, 0x43, 0xea, 0x47, 0xeb, 0xe5, 0xff, 0x03, 0x00, 0x00, 0xff, 0xff, 0x72, 0x62,
	0xdb, 0x8a, 0xc9, 0x15, 0x00, 0x00,
}

func (m *ServiceProviderRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceProviderRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServiceProviderRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintAttributes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintAttributes(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x22
	}
	if m.X500 != nil {
		{
			size, err := m.X500.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAttributes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.LaconicId) > 0 {
		i -= len(m.LaconicId)
		copy(dAtA[i:], m.LaconicId)
		i = encodeVarintAttributes(dAtA, i, uint64(len(m.LaconicId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.BondId) > 0 {
		i -= len(m.BondId)
		copy(dAtA[i:], m.BondId)
		i = encodeVarintAttributes(dAtA, i, uint64(len(m.BondId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ServiceProviderRecord_X500) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ServiceProviderRecord_X500) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ServiceProviderRecord_X500) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Country) > 0 {
		i -= len(m.Country)
		copy(dAtA[i:], m.Country)
		i = encodeVarintAttributes(dAtA, i, uint64(len(m.Country)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.StateName) > 0 {
		i -= len(m.StateName)
		copy(dAtA[i:], m.StateName)
		i = encodeVarintAttributes(dAtA, i, uint64(len(m.StateName)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.LocalityName) > 0 {
		i -= len(m.LocalityName)
		copy(dAtA[i:], m.LocalityName)
		i = encodeVarintAttributes(dAtA, i, uint64(len(m.LocalityName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.OrganizationName) > 0 {
		i -= len(m.OrganizationName)
		copy(dAtA[i:], m.OrganizationName)
		i = encodeVarintAttributes(dAtA, i, uint64(len(m.OrganizationName)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.OrganizationUnit) > 0 {
		i -= len(m.OrganizationUnit)
		copy(dAtA[i:], m.OrganizationUnit)
		i = encodeVarintAttributes(dAtA, i, uint64(len(m.OrganizationUnit)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.CommonName) > 0 {
		i -= len(m.CommonName)
		copy(dAtA[i:], m.CommonName)
		i = encodeVarintAttributes(dAtA, i, uint64(len(m.CommonName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WebsiteRegistrationRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WebsiteRegistrationRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WebsiteRegistrationRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintAttributes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintAttributes(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.TlsCertRef) > 0 {
		for k := range m.TlsCertRef {
			v := m.TlsCertRef[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAttributes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAttributes(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAttributes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.BuildArtifactRef) > 0 {
		for k := range m.BuildArtifactRef {
			v := m.BuildArtifactRef[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAttributes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAttributes(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAttributes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.RepoReference) > 0 {
		for k := range m.RepoReference {
			v := m.RepoReference[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAttributes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAttributes(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAttributes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintAttributes(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GitRepository) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GitRepository) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GitRepository) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintAttributes(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintAttributes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintAttributes(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.RepoReference) > 0 {
		i -= len(m.RepoReference)
		copy(dAtA[i:], m.RepoReference)
		i = encodeVarintAttributes(dAtA, i, uint64(len(m.RepoReference)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintAttributes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Binary) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Binary) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Binary) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintAttributes(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintAttributes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.RepoReference) > 0 {
		for k := range m.RepoReference {
			v := m.RepoReference[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAttributes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAttributes(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAttributes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.RuntimeVersion) > 0 {
		i -= len(m.RuntimeVersion)
		copy(dAtA[i:], m.RuntimeVersion)
		i = encodeVarintAttributes(dAtA, i, uint64(len(m.RuntimeVersion)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.TargetedArch) > 0 {
		i -= len(m.TargetedArch)
		copy(dAtA[i:], m.TargetedArch)
		i = encodeVarintAttributes(dAtA, i, uint64(len(m.TargetedArch)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.HashReference) > 0 {
		for k := range m.HashReference {
			v := m.HashReference[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAttributes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAttributes(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAttributes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DockerImage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DockerImage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DockerImage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintAttributes(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintAttributes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.RepoReference) > 0 {
		for k := range m.RepoReference {
			v := m.RepoReference[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAttributes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAttributes(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAttributes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.BinaryReference) > 0 {
		for k := range m.BinaryReference {
			v := m.BinaryReference[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAttributes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAttributes(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAttributes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ImageId) > 0 {
		i -= len(m.ImageId)
		copy(dAtA[i:], m.ImageId)
		i = encodeVarintAttributes(dAtA, i, uint64(len(m.ImageId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WatcherRegistrationRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WatcherRegistrationRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WatcherRegistrationRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintAttributes(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintAttributes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x22
	}
	if m.Wasm != nil {
		{
			size, err := m.Wasm.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAttributes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.RepoReference) > 0 {
		for k := range m.RepoReference {
			v := m.RepoReference[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAttributes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAttributes(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAttributes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAttributes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WatcherRegistrationRecord_WatcherMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WatcherRegistrationRecord_WatcherMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WatcherRegistrationRecord_WatcherMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ChainReference) > 0 {
		for k := range m.ChainReference {
			v := m.ChainReference[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAttributes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAttributes(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAttributes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintAttributes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WatcherRegistrationRecord_WASMBinary) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WatcherRegistrationRecord_WASMBinary) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WatcherRegistrationRecord_WASMBinary) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Metadata != nil {
		{
			size, err := m.Metadata.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAttributes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.HashReference) > 0 {
		for k := range m.HashReference {
			v := m.HashReference[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAttributes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAttributes(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAttributes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *WatcherRegistrationRecord_WASMBinaryMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WatcherRegistrationRecord_WASMBinaryMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WatcherRegistrationRecord_WASMBinaryMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ExecutionEngineVersion) > 0 {
		i -= len(m.ExecutionEngineVersion)
		copy(dAtA[i:], m.ExecutionEngineVersion)
		i = encodeVarintAttributes(dAtA, i, uint64(len(m.ExecutionEngineVersion)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.CompilerVersion) > 0 {
		i -= len(m.CompilerVersion)
		copy(dAtA[i:], m.CompilerVersion)
		i = encodeVarintAttributes(dAtA, i, uint64(len(m.CompilerVersion)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResponderContract) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponderContract) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponderContract) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintAttributes(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintAttributes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.WatcherRef) > 0 {
		for k := range m.WatcherRef {
			v := m.WatcherRef[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAttributes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAttributes(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAttributes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.AuctionRef) > 0 {
		for k := range m.AuctionRef {
			v := m.AuctionRef[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAttributes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAttributes(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAttributes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.ServiceProviderRef) > 0 {
		for k := range m.ServiceProviderRef {
			v := m.ServiceProviderRef[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAttributes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAttributes(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAttributes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *JSPackage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JSPackage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JSPackage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintAttributes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintAttributes(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintAttributes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.JsPackageRef) > 0 {
		for k := range m.JsPackageRef {
			v := m.JsPackageRef[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAttributes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAttributes(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAttributes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.RepoReference) > 0 {
		for k := range m.RepoReference {
			v := m.RepoReference[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAttributes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAttributes(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAttributes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ChainRegistrationRecord) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChainRegistrationRecord) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChainRegistrationRecord) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.GenesisHash) > 0 {
		for k := range m.GenesisHash {
			v := m.GenesisHash[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintAttributes(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintAttributes(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintAttributes(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.NetworkId) > 0 {
		i -= len(m.NetworkId)
		copy(dAtA[i:], m.NetworkId)
		i = encodeVarintAttributes(dAtA, i, uint64(len(m.NetworkId)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintAttributes(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintAttributes(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Type) > 0 {
		i -= len(m.Type)
		copy(dAtA[i:], m.Type)
		i = encodeVarintAttributes(dAtA, i, uint64(len(m.Type)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.IpldTypes) > 0 {
		for iNdEx := len(m.IpldTypes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.IpldTypes[iNdEx])
			copy(dAtA[i:], m.IpldTypes[iNdEx])
			i = encodeVarintAttributes(dAtA, i, uint64(len(m.IpldTypes[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintAttributes(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintAttributes(dAtA []byte, offset int, v uint64) int {
	offset -= sovAttributes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ServiceProviderRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BondId)
	if l > 0 {
		n += 1 + l + sovAttributes(uint64(l))
	}
	l = len(m.LaconicId)
	if l > 0 {
		n += 1 + l + sovAttributes(uint64(l))
	}
	if m.X500 != nil {
		l = m.X500.Size()
		n += 1 + l + sovAttributes(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovAttributes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovAttributes(uint64(l))
	}
	return n
}

func (m *ServiceProviderRecord_X500) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CommonName)
	if l > 0 {
		n += 1 + l + sovAttributes(uint64(l))
	}
	l = len(m.OrganizationUnit)
	if l > 0 {
		n += 1 + l + sovAttributes(uint64(l))
	}
	l = len(m.OrganizationName)
	if l > 0 {
		n += 1 + l + sovAttributes(uint64(l))
	}
	l = len(m.LocalityName)
	if l > 0 {
		n += 1 + l + sovAttributes(uint64(l))
	}
	l = len(m.StateName)
	if l > 0 {
		n += 1 + l + sovAttributes(uint64(l))
	}
	l = len(m.Country)
	if l > 0 {
		n += 1 + l + sovAttributes(uint64(l))
	}
	return n
}

func (m *WebsiteRegistrationRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovAttributes(uint64(l))
	}
	if len(m.RepoReference) > 0 {
		for k, v := range m.RepoReference {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAttributes(uint64(len(k))) + 1 + len(v) + sovAttributes(uint64(len(v)))
			n += mapEntrySize + 1 + sovAttributes(uint64(mapEntrySize))
		}
	}
	if len(m.BuildArtifactRef) > 0 {
		for k, v := range m.BuildArtifactRef {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAttributes(uint64(len(k))) + 1 + len(v) + sovAttributes(uint64(len(v)))
			n += mapEntrySize + 1 + sovAttributes(uint64(mapEntrySize))
		}
	}
	if len(m.TlsCertRef) > 0 {
		for k, v := range m.TlsCertRef {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAttributes(uint64(len(k))) + 1 + len(v) + sovAttributes(uint64(len(v)))
			n += mapEntrySize + 1 + sovAttributes(uint64(mapEntrySize))
		}
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovAttributes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovAttributes(uint64(l))
	}
	return n
}

func (m *GitRepository) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAttributes(uint64(l))
	}
	l = len(m.RepoReference)
	if l > 0 {
		n += 1 + l + sovAttributes(uint64(l))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovAttributes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovAttributes(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovAttributes(uint64(l))
	}
	return n
}

func (m *Binary) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.HashReference) > 0 {
		for k, v := range m.HashReference {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAttributes(uint64(len(k))) + 1 + len(v) + sovAttributes(uint64(len(v)))
			n += mapEntrySize + 1 + sovAttributes(uint64(mapEntrySize))
		}
	}
	l = len(m.TargetedArch)
	if l > 0 {
		n += 1 + l + sovAttributes(uint64(l))
	}
	l = len(m.RuntimeVersion)
	if l > 0 {
		n += 1 + l + sovAttributes(uint64(l))
	}
	if len(m.RepoReference) > 0 {
		for k, v := range m.RepoReference {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAttributes(uint64(len(k))) + 1 + len(v) + sovAttributes(uint64(len(v)))
			n += mapEntrySize + 1 + sovAttributes(uint64(mapEntrySize))
		}
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovAttributes(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovAttributes(uint64(l))
	}
	return n
}

func (m *DockerImage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ImageId)
	if l > 0 {
		n += 1 + l + sovAttributes(uint64(l))
	}
	if len(m.BinaryReference) > 0 {
		for k, v := range m.BinaryReference {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAttributes(uint64(len(k))) + 1 + len(v) + sovAttributes(uint64(len(v)))
			n += mapEntrySize + 1 + sovAttributes(uint64(mapEntrySize))
		}
	}
	if len(m.RepoReference) > 0 {
		for k, v := range m.RepoReference {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAttributes(uint64(len(k))) + 1 + len(v) + sovAttributes(uint64(len(v)))
			n += mapEntrySize + 1 + sovAttributes(uint64(mapEntrySize))
		}
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovAttributes(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovAttributes(uint64(l))
	}
	return n
}

func (m *WatcherRegistrationRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovAttributes(uint64(l))
	}
	if len(m.RepoReference) > 0 {
		for k, v := range m.RepoReference {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAttributes(uint64(len(k))) + 1 + len(v) + sovAttributes(uint64(len(v)))
			n += mapEntrySize + 1 + sovAttributes(uint64(mapEntrySize))
		}
	}
	if m.Wasm != nil {
		l = m.Wasm.Size()
		n += 1 + l + sovAttributes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovAttributes(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovAttributes(uint64(l))
	}
	return n
}

func (m *WatcherRegistrationRecord_WatcherMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovAttributes(uint64(l))
	}
	if len(m.ChainReference) > 0 {
		for k, v := range m.ChainReference {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAttributes(uint64(len(k))) + 1 + len(v) + sovAttributes(uint64(len(v)))
			n += mapEntrySize + 1 + sovAttributes(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *WatcherRegistrationRecord_WASMBinary) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.HashReference) > 0 {
		for k, v := range m.HashReference {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAttributes(uint64(len(k))) + 1 + len(v) + sovAttributes(uint64(len(v)))
			n += mapEntrySize + 1 + sovAttributes(uint64(mapEntrySize))
		}
	}
	if m.Metadata != nil {
		l = m.Metadata.Size()
		n += 1 + l + sovAttributes(uint64(l))
	}
	return n
}

func (m *WatcherRegistrationRecord_WASMBinaryMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.CompilerVersion)
	if l > 0 {
		n += 1 + l + sovAttributes(uint64(l))
	}
	l = len(m.ExecutionEngineVersion)
	if l > 0 {
		n += 1 + l + sovAttributes(uint64(l))
	}
	return n
}

func (m *ResponderContract) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ServiceProviderRef) > 0 {
		for k, v := range m.ServiceProviderRef {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAttributes(uint64(len(k))) + 1 + len(v) + sovAttributes(uint64(len(v)))
			n += mapEntrySize + 1 + sovAttributes(uint64(mapEntrySize))
		}
	}
	if len(m.AuctionRef) > 0 {
		for k, v := range m.AuctionRef {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAttributes(uint64(len(k))) + 1 + len(v) + sovAttributes(uint64(len(v)))
			n += mapEntrySize + 1 + sovAttributes(uint64(mapEntrySize))
		}
	}
	if len(m.WatcherRef) > 0 {
		for k, v := range m.WatcherRef {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAttributes(uint64(len(k))) + 1 + len(v) + sovAttributes(uint64(len(v)))
			n += mapEntrySize + 1 + sovAttributes(uint64(mapEntrySize))
		}
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovAttributes(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovAttributes(uint64(l))
	}
	return n
}

func (m *JSPackage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RepoReference) > 0 {
		for k, v := range m.RepoReference {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAttributes(uint64(len(k))) + 1 + len(v) + sovAttributes(uint64(len(v)))
			n += mapEntrySize + 1 + sovAttributes(uint64(mapEntrySize))
		}
	}
	if len(m.JsPackageRef) > 0 {
		for k, v := range m.JsPackageRef {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAttributes(uint64(len(k))) + 1 + len(v) + sovAttributes(uint64(len(v)))
			n += mapEntrySize + 1 + sovAttributes(uint64(mapEntrySize))
		}
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovAttributes(uint64(l))
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovAttributes(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAttributes(uint64(l))
	}
	return n
}

func (m *ChainRegistrationRecord) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAttributes(uint64(l))
	}
	if len(m.IpldTypes) > 0 {
		for _, s := range m.IpldTypes {
			l = len(s)
			n += 1 + l + sovAttributes(uint64(l))
		}
	}
	l = len(m.Type)
	if l > 0 {
		n += 1 + l + sovAttributes(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovAttributes(uint64(l))
	}
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovAttributes(uint64(l))
	}
	l = len(m.NetworkId)
	if l > 0 {
		n += 1 + l + sovAttributes(uint64(l))
	}
	if len(m.GenesisHash) > 0 {
		for k, v := range m.GenesisHash {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovAttributes(uint64(len(k))) + 1 + len(v) + sovAttributes(uint64(len(v)))
			n += mapEntrySize + 1 + sovAttributes(uint64(mapEntrySize))
		}
	}
	return n
}

func sovAttributes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozAttributes(x uint64) (n int) {
	return sovAttributes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ServiceProviderRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttributes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ServiceProviderRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ServiceProviderRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BondId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BondId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LaconicId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LaconicId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field X500", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.X500 == nil {
				m.X500 = &ServiceProviderRecord_X500{}
			}
			if err := m.X500.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAttributes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAttributes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ServiceProviderRecord_X500) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttributes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: X500: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: X500: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommonName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommonName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrganizationUnit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrganizationUnit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrganizationName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrganizationName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalityName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LocalityName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StateName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StateName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Country", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Country = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAttributes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAttributes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WebsiteRegistrationRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttributes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WebsiteRegistrationRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WebsiteRegistrationRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepoReference", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RepoReference == nil {
				m.RepoReference = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAttributes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAttributes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAttributes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAttributes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAttributes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAttributes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAttributes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAttributes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAttributes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.RepoReference[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BuildArtifactRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BuildArtifactRef == nil {
				m.BuildArtifactRef = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAttributes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAttributes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAttributes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAttributes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAttributes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAttributes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAttributes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAttributes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAttributes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.BuildArtifactRef[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsCertRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TlsCertRef == nil {
				m.TlsCertRef = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAttributes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAttributes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAttributes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAttributes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAttributes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAttributes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAttributes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAttributes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAttributes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.TlsCertRef[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAttributes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAttributes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GitRepository) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttributes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GitRepository: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GitRepository: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepoReference", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepoReference = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAttributes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAttributes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Binary) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttributes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Binary: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Binary: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashReference", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HashReference == nil {
				m.HashReference = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAttributes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAttributes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAttributes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAttributes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAttributes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAttributes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAttributes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAttributes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAttributes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.HashReference[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetedArch", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetedArch = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RuntimeVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepoReference", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RepoReference == nil {
				m.RepoReference = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAttributes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAttributes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAttributes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAttributes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAttributes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAttributes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAttributes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAttributes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAttributes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.RepoReference[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAttributes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAttributes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DockerImage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttributes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DockerImage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DockerImage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImageId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImageId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BinaryReference", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BinaryReference == nil {
				m.BinaryReference = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAttributes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAttributes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAttributes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAttributes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAttributes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAttributes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAttributes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAttributes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAttributes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.BinaryReference[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepoReference", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RepoReference == nil {
				m.RepoReference = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAttributes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAttributes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAttributes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAttributes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAttributes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAttributes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAttributes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAttributes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAttributes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.RepoReference[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAttributes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAttributes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WatcherRegistrationRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttributes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WatcherRegistrationRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WatcherRegistrationRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &WatcherRegistrationRecord_WatcherMetadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepoReference", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RepoReference == nil {
				m.RepoReference = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAttributes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAttributes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAttributes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAttributes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAttributes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAttributes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAttributes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAttributes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAttributes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.RepoReference[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wasm", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Wasm == nil {
				m.Wasm = &WatcherRegistrationRecord_WASMBinary{}
			}
			if err := m.Wasm.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAttributes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAttributes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WatcherRegistrationRecord_WatcherMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttributes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WatcherMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WatcherMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainReference", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChainReference == nil {
				m.ChainReference = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAttributes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAttributes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAttributes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAttributes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAttributes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAttributes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAttributes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAttributes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAttributes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ChainReference[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAttributes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAttributes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WatcherRegistrationRecord_WASMBinary) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttributes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WASMBinary: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WASMBinary: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HashReference", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HashReference == nil {
				m.HashReference = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAttributes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAttributes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAttributes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAttributes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAttributes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAttributes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAttributes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAttributes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAttributes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.HashReference[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Metadata == nil {
				m.Metadata = &WatcherRegistrationRecord_WASMBinaryMetadata{}
			}
			if err := m.Metadata.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAttributes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAttributes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WatcherRegistrationRecord_WASMBinaryMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttributes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WASMBinaryMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WASMBinaryMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompilerVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CompilerVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutionEngineVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExecutionEngineVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAttributes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAttributes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponderContract) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttributes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponderContract: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponderContract: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceProviderRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ServiceProviderRef == nil {
				m.ServiceProviderRef = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAttributes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAttributes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAttributes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAttributes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAttributes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAttributes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAttributes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAttributes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAttributes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ServiceProviderRef[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuctionRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AuctionRef == nil {
				m.AuctionRef = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAttributes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAttributes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAttributes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAttributes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAttributes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAttributes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAttributes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAttributes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAttributes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.AuctionRef[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WatcherRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WatcherRef == nil {
				m.WatcherRef = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAttributes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAttributes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAttributes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAttributes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAttributes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAttributes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAttributes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAttributes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAttributes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.WatcherRef[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAttributes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAttributes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JSPackage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttributes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JSPackage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JSPackage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepoReference", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RepoReference == nil {
				m.RepoReference = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAttributes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAttributes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAttributes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAttributes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAttributes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAttributes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAttributes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAttributes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAttributes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.RepoReference[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JsPackageRef", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JsPackageRef == nil {
				m.JsPackageRef = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAttributes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAttributes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAttributes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAttributes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAttributes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAttributes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAttributes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAttributes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAttributes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.JsPackageRef[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAttributes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAttributes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChainRegistrationRecord) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAttributes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChainRegistrationRecord: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChainRegistrationRecord: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpldTypes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpldTypes = append(m.IpldTypes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NetworkId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NetworkId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GenesisHash", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAttributes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAttributes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GenesisHash == nil {
				m.GenesisHash = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAttributes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAttributes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthAttributes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthAttributes
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAttributes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthAttributes
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthAttributes
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipAttributes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthAttributes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.GenesisHash[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAttributes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAttributes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAttributes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAttributes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAttributes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAttributes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupAttributes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthAttributes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthAttributes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAttributes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupAttributes = fmt.Errorf("proto: unexpected end of group")
)
